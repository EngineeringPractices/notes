arch-01
-------

# 00. XXX

* 思维模式
  - 架构设计：判断与取舍;
  - 程序设计：逻辑与实现．
* 内容
  - 架构基础
  - 高性能
  - 高可用
  - 高可扩展

# 01. 架构是什么

## 基本概念

### 系统与子系统

`系统`
  - *关联*　由一群有*关联*的个体组成．不是任意无关的个体.(发动机，PC无关联)
  - *规则*  系统内个体按照一定的规则运作．（分工，发动机，变速箱）
  - *能力*  系统能力不是个体能力之和，产生新能力．(发动机，轮子..汽车)

`子系统`
  - 也是一群有关联的个体组成的系统
  - 是另一个更大的系统的一部分

### 模块与组件

`模块(Module)` 程序＋数据结构，一致而有紧密关联的软件组织；模块接口，协作单位.
逻辑角度划分系统为模块，目的是职责分工． (Login, user-info, ...)

`组件(Component)` 自包含，可编程，可重用，语言无关，可组装的软件单元．物理角度划分系统为组件，目的是单元复用． (Nginx, DB, LB).

### 框架与架构

`框架(framework)` 实现某标准或特定基本认为的组件规范，及基础软件．（MVC, J2EE, Sprint)
`架构(Architect)` 基础结构,准则,及结构的描述．

**软件架构** 软件系统的顶层结构
  - 包含哪些个体（子系统，模块，组件）
  - 运作规则　个体运作，协作规则

# 02. 架构历史

> 控制复杂度: 逻辑复杂度，软件复杂度，系统复杂度

* 结构化程序设计(解决逻辑过于复杂)
  - 软件危机，软件工程，人月神话  
  - 自顶向下，逐步细化，模块化　（面向过程）
* 面向对象(解决可扩展,软件跟不上业务硬件快速变化)
  - 考虑复用，可扩展
* 架构设计(解决大系统的组织问题)
  - 系统庞大，内部耦合严重，开发效率低
  - 系统间耦合严重，影响修改和可扩展
  - 系统逻辑复杂，易出问题，难排查

# 03. 架构目的

误区：

* 为架构而架构（架构重要是为什么？)
  - 没有架构系统也能跑；(事实如此)
  - 架构不提高开发效率；(事实如此)
  - 不促进业务发展.(事实如此)
  - 并非所有系统都需要做架构设计．(事实如此)
  - 公司要求必须做
  - 为了＂高性能，高可用，可扩展＂　（过度设计）
  - XXX公司这么做，我们也要这么做
  - XXX技术很流行，我们要用起来

架构的目的：**解决软件 *系统* 的 *复杂度* 带来的问题**.

做好架构，需要：

* 熟悉和理解需求，识别复杂性所在的地方（找到问题点）；针对性的做架构设计．
* 架构不需要面面具到，理解复杂点，才能有所取舍，有的放失．

# 04. 复杂度来源：追求高性能

* 单机为提高性能，会带来复杂度：
  - 人们对性能，功能，体验的追求；硬件的发展；
  - 如何充分利用CPU，内存，网卡，存储，．．．
  - 批处理，多线程／进程，事件驱动／异步编程，ＳＭＰ，ＮＵＭＡ　ＭＰＰ　, Cache
* 多机集群为提高性能，会带来复杂度．
  - 业务的发展，移动互联网爆发，双11，红包
  - 单纯增加机器不能解决问题
  　　- 任务分配；调度器（ＬＢ），
    　- 任务分解：注册，消息，

# 05. 复杂度来源：追求高可用

`高可用` 系统**无中断**执行其功能的能力．

单个硬件，单个软件无法做到无中断．通过＂冗余＂的方法，冗余增加了高可用也带来了复杂性．

* 计算高可用(无状态)

　任务分配器+多个无状态服务器模型：

　- 任务分配器
　- 连接管理，异常处理（分配器和业务服务器间）
　- 分配算法（调度）
　- 服务发现管理(ZooKeeper, Memcached)

* 存储高可用()
 - 数据一致性问题(数据＋逻辑=业务)
 - 数据传输延时问题
 - 传输线路的可靠性

 CAP理论，存储不可能同时满足＂一致性，可用性，分区容错性＂，最多只能满足两个，需要取舍．

* 高可以状态决策 正常，异常状态判断（健康检查), 状态检查不可能完全准确

`独裁式`

 　　- 信息搜集者，裁决
 　　- 冗余个体上报状态
    优点：决策不会发生混乱，缺点：决策者是单点，如果对决策者做决策，无限递归．

`协商式`

即主备协商模式：

1. 架构简单，不会存在决策者的单点
2. 连接中断时，可能出现双主，或者无法成为主的情况

`民主式`

多个独立个体投票进行决策，选举leader（ZooKeeper集群，选举算法Paxos）

优点：
- 没有独裁式的单点问题，
- 没有协商式的双主问题
缺点
- 但算法，实现复杂
- 有脑裂问题，集群连接中断，形成两个分隔的集群，各自进行决策导致行为不一致．出现两个主节点．
- 解决脑裂问题可能导致系统可用性下降

没有完美的方案．　

# 06. 复杂度来源：追求可扩展性

新需求出现时，系统不需要或者仅需要少量修改，无需重构重建。做到 **正确预测变化，完美封装变化**.

* 软件开发：面向对象(代码复用)，设计模式

## 预测变化

* 不能每个点都考虑可扩展（有所取舍，不能过度设计）
* 不能完全不考虑可扩展性
* 要尽量准确预测，但任何预测都可能出错

## 应对变化

> 没有什么事情加一层封装不能解决的。HAL， 中间件， net_device, vfs, ...

* 将“变化”封装在一个“变化层”
  - 将系统拆分成*变化层*和*稳定层*
  - 合理设计层与层的*接口*
* 提炼出一个“抽象层”和一个"实现层" （HAL，vfs, 设计模式， 抽象出类，...）
