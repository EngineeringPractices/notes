Web性能权威指南　笔记
==================

Ch1. 延迟与带宽
-------------

# **延时** 构成

* 传播延迟：　信号传播速度，距离的函数，不超过光速．
* 传输延迟：　bits转移到链路的时间，*消息长度* 和 *链路速率* 的函数 (Transmit, TX)
* 处理延迟：　处理分组首部，检查位错误，确定分组目标 (processing)
* 排队延迟：　排队等待处理的时间 (queuing)，路由器,网卡分组队列等

# 光速与传播延时

光速与介质的折射率（铜线，光纤）．纽约到伦敦距离光纤RTT 56ms，纽约到悉尼　160ms．

> CDN：在不能提高传播速度的情况下，缩短服务器与用户的距离．

# 延迟的最后一公里

延迟相当大一部分在最后几公里，而非跨洋产生．*接入* 互联网的路由器节点，需要数十ms把分组传递到ISP的主路由器．光纤接入18ms，Cable接入26ms，DSL 43ms．`traceroute`可反映没跳的耗时．

> traceroute通过　TTL和ICMP Time Exceeded消息实现．或者记录路由．

多数网站的**性能瓶颈是延迟**，而不是带宽!

# 带宽

* 网络核心的带宽
　光纤 一个波长最大容量171G bps，一条光纤400种波长，　共70T　bit/s．海底光缆带宽只使用了20%．
* 网络边缘的带宽
　全球　3.1Mbps, 韩国　14.2 Mbps, 美国　8.6Ｍbps．

> http://speedtest.net

Ch2. TCP的构成
-------------

# TCP三次握手

TCP三次握手，连接双方都需要经历一次完整的RTT才能开始传输数据．

> TCP快速打开(TFO): 降低HTTP事务网络延迟15%．Linux 3.7.

# 拥塞防御与控制

## 流量控制

* 滑动窗口

  - 通告自己的接收窗口`rwnd`

  `优化`：窗口扩大因子选项 `net.ipv4.tcp_window_scaling`

* 慢启动

  `优化`：提高cwnd初始值为10．以更少的RTT尽快达到带宽的极限，对新建连接，大量短连接的应用帮助很大．Linux 2.6.39(最好是2.6.32).

  - 慢启动重启(Slow-Start Restart, SSR)，连接空闲一段时间后，重置cwnd．因为网络情况可能已经发生变化．

  `优化`：关闭`net.ipv4.tcp_window_scaling`

* 拥塞避免

  超过慢启动阀值(`ssthresh`)进入拥塞避免(congestion avoidance)．发生丢包，则sstresh减半，cwnd设置为新的ssthresh并进入拥塞避免．

  TCP流量曲线呈锯齿状．

  TCP Tahoe/Reno
  TCP Vegas/New Reno/BIC/CUBIC/Compound/BBR.

* 快速重传，快速恢复

# 带宽时延积

窗口大小和RTT决定能否填满带宽时延积BDP，高BDP(长肥管道)情况下,默认的接受窗口可能不足，所以需要窗口扩大因子．

#　队首阻塞

某个分组没收到，后续收到的分组不能交付给应用层．(Head of Line, HOL阻塞）．有时不需要按序交付，比如ptp下载，比如每个消息独立（多个HTTP请求），比如每个消息覆盖前一次操作，比如音频，视频．

# 针对TCP的优化建议

* TCP三次握手增加整个RTT
* 慢启动并应用到每个连接
* 流量，拥塞控制影响所有连接吞吐量
* 吞吐量由当前拥塞窗口大小控制

## 服务器配置调优

* 增大TCP的初始化拥塞窗口　（升级内核）cwnd-init为10 Linux 3.2+
* 关闭慢启动重启
* 打开窗口扩大因子选项
* TCP快速打开(TFO)

## 应用程序行为调优

* 能少发就少发(减少冗余数据，压缩数据)
* 如果不能让传输更快，就让传输距离缩短(CDN)
* 重用TCP连接是提升性能的关键

Ch3. UDP的构成
-------------

没有周密的计划和规划，一流的构想也会沦为二流的TCP实现．

# UDP与NAT

## 连接状态超时

TCP有严密的状态机，路由设备可以监控连接状态，根据情况创建删除路由表条目．
UDP没有握手，没有连接终止，没有状态．所以NAT必须保存每个UDP流的信息，只能设置定时器，但是定时多长？可以使用keepalive不断激活NAT设备的计时器．

## NAT穿透

P2P应用需要端到端双向通信

- STUN
- TURN  中继代理
- ICE

# 针对UDP的优化建议

* UDP应用*必须*容忍各种Internet路径条件
* UDP应用*应该*控制传输速度
* UDP应用*应该*对所有流量进行拥塞控制
* UDP应用*应该*使用与TCP相近的带宽
* UDP应用*应该*准备基于丢包的重发机制
* UDP应用*应该*不发送大于PMTU的数据报
* UDP应用*应该*处理报文丢失，重复，乱序
* UDP应用*应该*足够稳定以支持２分钟以上的交付延迟
* UDP应用*应该*支持IPv4 UDP校验和，必须支持IPv6校验和
* UDP应用*可以*在需要时使用keep-alive(最小间隔１５秒)

> WebRTC符合一以上要求.

Ch4. 传输层安全(TLS)
------------------

* 1999: TLS 1.0, 对应SSL 3.0，区别不明显，但影响互操作．
* 2006: TLS 1.1
* 2008: TLS 1.2
* 2018: TLS 1.3

![tls](./tls.png)

# 加密，身份验证与完整性

* 加密 (Encrypto)
  - 混淆数据的机制．

* 身份验证（Authentication）
  - 验证身份标识有效性的机制

* 完整性（Integration）
  - 检测消息是否被串改或者伪造的机制

### 密钥协商

连接双方需要就加密数据的*密钥套件*和*密钥*进行协商一致．`非对称密钥加密`，不必通信双方实现＂认识＂，且协商过程通过非加密通道完成．

### 身份验证

这个验证需要建立＂认证机构信任链＂(Chain of Trust and Certification Authorities)．

### 消息封装

使用消息验证码(MAC, Message Authentication Code)签署每条消息．MAC是一个单向加密哈希函数，密钥由双方协商确定．发送方发送TLS Record时生成MAC并附加到消息中，接收端通过计算和验证这个MAC值来判断消息的完整性和可靠性．

HTTP:80被各种设备很好的支持，如果脱离它会造成各种异常（比如私有协议，私有选项无法通过中间设备，防火墙）．新的基于HTTP的协议，比如WebSocket, SPDY(HTTP2)基于HTTPS信道，以便绕过中间代理．

# TLS握手

![tls-handshake](tls-handshake.png)

协商：

* TLS版本
* 加密套件
* 验证证书

握手过程，

- 0ms:   完成三次握手的RTT
- 56ms:  Client发送TLS协议版本，所支持的加密套件列表，支持或希望使用的TLS选项
- 84ms:  Server选择TLS版本，加密套件; 附上自己的证书．
　　　　　 可选：发送一个请求，要求Client提供证书及提供TLS扩展参数．
- 112ms: 协商确定版本和加密套件后，客户端生成新的*对称密钥*，用服务器的公钥加密，发送给服务器．
　　　　　 以上，除了加密的对称密钥，其他全是明文．
- 140ms: 服务器用私钥解密出*对称密钥*后，通过验证MAC检验消息完整性，发送一个加密的"Finish"．
- 168ms: 客户端使用之前生成的对称密钥解密Finish，验证MAC．后续开始发送应用数据．

相对TCP握手，还多两次RTT，增加延迟．

# TLS会话恢复

* TLS额外的握手造成**延时**
* 非对称加密的计算两造成**性能损失**

Session回复(共享)，在多个连接共享协商后的安全密钥．

### 会话标识符(Session ID)

1. `Session ID`：服务器创建的32 Byte，并作为`ServerHello`的一部分发送．
　　Server内部，维护Session-ID和协商后的会话参数．包括对称密钥．
2. Client可以保存Session-ID，并用于随后的`ClientHello`.
3. Server需要保证Session-ID的缓存及清除．

![](tls-session-id.png)

这样，节省一次RTT，以及非对称密钥的加,　解密计算．

但是Session-ID对Server内部的维护提出挑战，如何缓存大量的连接信息，如何淘汰不要的连接信息，如何跨服务器共享．

### 会话记录单(Session Ticket)

为解决Session-ID在服务器端维护的问题，提出了`Session Ticket`机制，不需要Server为每个Client维护会话状态．

Server在（第一次）完整的TLS握手最后一次报文交换中，添加一条＂加密过的＂　New Session Ticket，只有Server知道如何解密．

Client收到后保存起来，在后续会话的ClientHello中添加SessionTicket．这样将会话数据保存在客户端．

又称＂无状态恢复＂，但Session Ticket仍要解决负载均衡器多Server的问题，比如所有Server共享密钥．并定期轮换密钥．

# 信任链与证书颁发机构

身份验证流程

# 针对TLS的优化建议

* 非对称加密计算量大：硬件SSL offload(计算集群)　（现在Facebook, Google已经不用专门硬件了）
　硬件的发展使得不需要额外的机器和硬件．
* Session-ID恢复
* Session-Ticket无状态恢复
* 尽量重用TCP连接．
* CDN,代理服务器，缩短距离(一边处理Ｃlient的连接,一边和RS保持TLS长连接池)

Ch9. HTTP简史
------------

* HTTP 1.0 1995
  - 默认短连接，可通过（`Connection: Keep-Alive`)启用长连接．
* HTTP 1.1 1997 RFC2068, 1999 RFC2616
  - 默认使用持久连接（除非`Connection: close`)
  - 支持分块编码传输（`Transfer-Encoding: chunked`）在一次message的body返回多个资源．
  - 字节范围请求（断点续传）
  - 增强的缓存机制(`Cache-Control: max-age=0, no-cache`)
  - 传输编码(`Transfer-Encoding`)
  - 请求管道
  - 内容(MIME)，编码，字符集，语言的协商
* HTTP2.0: 2012 (SPDY是HTTP2.0的基础)
  - 改善传输性能，实现高吞吐量，低延迟．
  - 向前兼容HTTP 1.x

Ch10. Web性能要点
---------------

* 超文本文档
* 富媒体网页
* 交互试Web应用

> 页面加载时间PLT, Page Load Time.

# 剖析现代Web应用

一个普通的Web应用由下列内容构成(2013)

* 90 个请求,发送到 15 个主机,总下载量 1311 KB
  - HTML:10 个请求,52 KB
  - 图片:55 个请求,812 KB
  - JavaScript:15 个请求,216 KB
  - CSS:5 个请求,36 KB
  - 其他资源:5 个请求,195 KB

根据用户感觉，需要在250ms内渲染页面．

* 0~100ms，很快
* 100~300ms, 有点慢
* 300~1000ms,
* > 1000ms, 想离开
* > 10000ms, 不能用

分析资源瀑布`http://www.webpagetest.org/`

# 性能来源：计算，渲染和网络访问

## 更多带宽其实不（太）重要

带宽很重要．但是对于较小的资源比如网页，RTT就成了瓶颈．

* 浏览web主页受限于延迟
* 观看视频受限于带宽

## 延迟是性能瓶颈

![latency](latency.png)

Ch11. HTTP 1.x
---------------

HTTP 1.1引入的重要特性：

* 连接持久化：以支持连接重用
* 分块传输编码：以支持流式响应
* 请求管道：以支持并行请求处理
* 字节服务：以支持基于范围的资源请求
* 改进的缓存机制

性能优化最佳实践：

* 减少DNS查询
  每次查询都意味着一次RTT，用URL的path而非domain部分来区分资源，以便减少DNS查询．
* 减少HTTP请求
　去掉不必要的HTTP资源请求
* 使用CDN
  地理上减少RTT，增加吞吐量．
* 使用缓存（`Expires`首部，`ETag`标签）
　使用缓存，并制定缓存时间．避免HTTP请求．
* Gzip资源
　压缩资源减少传输．尤其文本的压缩率非常高．
* 避免HTTP重定向
　重定向意味着新的DNC,TCP连接，HTTP请求延迟．

# 持久连接的优点

# HTTP管道

Client同时发起多个请求，不必等服务器完成响应后再发下一个请求．

![](request-pipeline.png)

不过HTTP 1.x有个有限制，Response只能严格的串行返回．不影响响应数据交错，所以服务器这边没法并行处理．
也就是HTTP的**队首阻塞**问题．之前提到过TCP的队首阻塞．

* 一个慢响应阻塞后续请求（的返回）
* 并行处理时Server需要缓冲响应，占用资源
* 中间代理是否能兼容管道，确保可靠性
* 一个响应失败而终止TCP的话(某个req设置了`Connection: Close`或者关闭连接)，会影响其他请求

![](server-con.png)

# 使用多个TCP连接

HTTP 1.x不支持多路复用，但是可以打开多个TCP连接，在不同的连接中发送请求．现代浏览器都支持同时打开6个TCP连接．

好处不说了，几乎６倍的减少总RTT；坏处是

* 占用更多Client，Server，及Proxy的资源，包括socket, 内存，CPU．
* TCP之间竞争带宽
* 并发处理，实现复杂性高（开发成本）
* 应用的并行能力

# 域名区分

减少服务器压力，利用并发TCP连接，但增加DNS查询次数．

Ch12. HTTP 2.0
---------------

更快，更简单，更健壮．将HTTP 1.1提高性能的权益之技一笔购销，把解决问题的方案内置在传输层中．

* 支持请求，响应多路复用
* 压缩HTTP首部降低开销
* 支持优先级
* 支持服务器推送
* 新的流量控制，错误处理，更新机制
* 向前兼容，不改变HTTP的语义（方法，状态码，URI，headers等）

# 历史及其与SPDY的渊源

2009年Google发布SPDY，解决HTTP 1.1的性能问题，减少网游加载延迟．
2012年各大厂商（Chrome, Firefox, Opera, 和谷歌，Twitter, Facebook网站支持SPDY．
HTTP-WG开始制定HTTP 2.0标准．

# 走向HTTP 2.0

* 改善延迟且可度量
* 解决HTTP头端阻塞
* 并行操作无需多条TCP连接，改进TCP利用率，尤其拥塞控制
* 向前兼容
* 明确和HTTP 1.x的互操作，尤其中间设备
* 新的可扩展机制及策略

# 设计和技术目标

### 二进制分帧层

HTTP语义（动词，方法，首部，URI）不变，编码方式改成二进制．

![](h2-bin-msg.png)

### 流，消息和帧

`流`　双向字节流，所有通信在一个TCP连接完成，流是连接中的虚拟通道．有唯一ID.
`消息`　逻辑上的HTTP消息，与HTTP逻辑消息对应的有一系列数据帧（一个或多个）
`帧`　HTTP 2.0最小通信单位，包含帧首部，会表述出所在流．

![](h2-stream-message-frame.png)

### 多向请求与响应

HTTP 1.x的并行请求必须使用多条TCP连接实现，会导致队首阻塞。HTTP 2.0使用新的二进制分帧突破了这个限制。Client和Server可以吧HTTP消息分解为相互不不依赖的帧，然后乱序发送。

> 并没有彻底解决队首阻塞，因为使用同一条TCP，依然有TCP层面的队首阻塞问题（见QUIC）。

![](multi-req-res.png)

### 请求优先级

支持交错传输后，为进一步提升性能，支持31Bit的优先级。 0最高，2^31-1最低。

### 每个来源有一个连接

HTTP 2.0不再依赖多条TCP连接实现多流并行。因此，所有HTTP 2.0连接都是持久化的，且只需要一条长连接。

### 流量控制

类似滑动窗口的流量控制。

* 流量控制基于每一跳进行(proxy)，而非端到端。
* 流量控制基于*窗口更新*帧，接收方通过自己准备接收某个stream的多少字节，以及整个连接要接收多少字节。
* 流量控制窗口大小使用`WINDOW_UPDATE`帧，指定stream-ID及窗口大小递增值。
* 流量控制有方向性。
* 流量控制可以由接收方禁用。

### 服务器推送

Server可以对一个Client的请求发送多个相应，即处理响应req外，可以额外推送资源。

![](h2-push.png)

### 首部压缩

每次通信携带一组首部，HTTP 1.x中，大约增加500~800字节纯文本，算上cookie，可能有上千字节。

* HTTP 2.0在Client/Server端使用"Header Table"来跟踪、存储之前发生的`Key-Value`对，对于相同的数据，不再通过Reqeust/Response发送。
* "Header Table"在HTTP 2.0连接周期内始终存在，有Server/Client共同渐进更新。
* 新的Header要么追加到Table，要么替换之前的值。

![](h2-header-comp.png)

# 二进制分帧简介

![](h2-bin-frame.png)

* Type
  - DATA: 传输HTTP body。
  - HEADERS： 传输HTTP Header.
  - PRIORITY：指定或重新指定资源的优先级
  - RST_STREAM：流的非正常终止。
  - SETTINGS：通知两端通信方式的配置数据。
  - PUSH_PROMISE：发出创建流和副而且引用资源的要约。
  - PING：计算RTT，及Keepalive.
  - GOAWAY: 通知对段停止在当前连接中创建流。
  - WINDOW_UPDATE：更新流或连接的接收窗口。
  - CONTINUATION：继续一系列Header块片段。

Ch13. 优化应用的交付
------------------

![](all-layers.png)

各个层次的优化实践。

# 经典的性能优化最佳实践

* 减少DNS的查找

   查找需要RTT，会阻塞后续请求。可以合并域名减少查找。

* 重用TCP连接

   减少3次握手和慢启动延迟。

* 减少HTTP重定向

   重定向很浪费时间(DNS/TCP/...)，最佳重定向次数为0.

* 使用CDN

  不能减少延迟，就缩短RTT。

* 去掉不必要的资源

  任何请求都不如没有请求快。

* 在客户端缓存资源

  `Cache-Control`, `Last-Modified`, `ETag`。

* 传输压缩过的内容

  文本的压缩率很高。去掉不必要的元素。选择最优的图片格式和分辨率。

* 消除不必要的请求开心

   减少Header数据，cookie。

* 并行处理请求和响应

* 针对协议版本采取优化措施
